\chapter{Technology}


\section{Wombat}

\section{Python}

\section{C++}

\section{Rust}
\textbf{Author: Jeremy Sztavinovszki}

Rust is a general purpose multi paradigm programming language used in many fields ranging from embedded programming to web development. Although it is a relatively young language, having released its version 1.0 on May 15th 2015, it has seen great adoption from developers and has a big community. The language tries to be as fast as possibly, while still remaining memory-safe, which it achieves using its borrow checker. Even though it is possible to write unsafe code in Rust, that is not checked by the borrow checker, it is custom to keep the unsafe parts as small as possible.
Rust has a great ecosystem driven by the Rust Foundation and the Rust community. There are many tools, such as cargo, or rust-gdb, that provide great developer experience.
Right now there is now standardized async-runtime, so you normally use runtimes like tokio, async-std, or smol for programming asynchronously.

\section{gRPC}

\section{Bluetooth Low Energy}
\textbf{Author: Jeremy Sztavinovszki}

Bluetooth Low Energy (BLE) is a low powered, low cost, low bandwidth radio communication technology, that was originally developed at Nokia in a project named Wibree. It was later noticed by the Bluetooth Special interest group and became part of the Bluetooth 4.0 Core Specification. Nowadays it is often used in all things ranging from wireless headphones to IOT devices and has seen great adoption in many different areas. The BLE protocol Stack, like others (e.g. TCP/IP) is separated into different layers. The layers are split into 3 overarching layers. which are the Application, Host and Controller layers.

\subsection{Application-Layer}
Much like the TCP/IP-Stack the BLE-Stack also comes with an Application-Layer. The Application-Layer is the highest layer in the stack and is responsible for containing logic, user interface and handling the data of the application using BLE. It often determines which usage model is used in the Host-Layers.
It is the layer that bundles all of the functionality of BLE together and abstracts it in such a way, that it is useable for ordinary users.

\subsection{Host-Layer}
The Host-Layer itself splits off into several layers. It is made up of all layers above the Host Side HCI, except the Application Layer, but not only that. It also contains profiles, which
determine how the protocols in the host layer should work with oneanother depending on the usage model, that has been chosen by the Application.

\subsubsection{Generic Access Profile GAP}
The Generic Access Profile, or GAP defines which role a BLE-Device has in communication. These roles determine how the device, as well as other devices act, when sending or receiving data.
A BLE device can take on 4 distinct roles, which are as follows.

\begin{itemize}
\item{Broadcaster}
\item{Observer}
\item{Peripheral}
\item{Central}
\end{itemize}


\subsubsection{Generic Attribute Profile GATT}
GATT

\subsubsection{Logical Link Protocol and Adaptation Protocol L2CAP}
L2CAP

\subsubsection{Attribute Protocol ATT}
ATT

\subsubsection{Security Manager Protocol SMP}
test

\subsubsection{Host Controller Interface HCI (Host side)}
test

\subsection{Controller}
The controller is the layer works closely with the hardware. It contains the following layers

\subsubsection{Host Controller Interface (Controller side)}
test

\subsubsection{Link Layer LL}
Hidden behind the HCI is the Link Layer. It is usually implemented as a conglomeration of custom hardware, as well as software it is the only part
of the protocol stack, that needs to have real-time capabilities, because it needs to work with the timing requirements defined by the specification.
In order to avoid overloading the CPU running the software layers of the stack, the easily automated, or computationally expensive parts are implemented in circuitry.


\subsubsection{Physical Layer PHY}
The physical layer is made up of the actual hardware, that is capable of modulating and demodulating the analog signals sent by radio and turning them into digital information. It uses the 2.4GHz ISM \footcite{ism} radio band, which it splits into 40 channels (37 for transmitting data and 3 for advertising connections and broadcasts) from 2.4GHz to 2.4835GHz. It uses FHSS to avoid radio interference, which is important, because classic bluetooth, as well as 2.4GHz use the same frequency band. The modulation rate chosen for BLE is 1.0Mbit/s, which means that is the physical throughput limit. However because of protocol overhead this physical throughput level is never reached.

\section{Libraries}

\subsection{Rusqlite}
\textbf{Author: Christoph Fellner}

Rusqlite\footcite{rusqlite} is a library for using SQLite from Rust code similar to rust-postgres. It provides an easy-to-use interface to work with SQLite databases. Using 
the functions provided by rusqlite you can perform all the common database operations, such as creating tables, inserting Data, querying data, and more simply within your code. 
We choose this library for SQLite mainly because of three reasons:
\begin{enumerate}
    \item \textbf{Portability:} SQLite databases can be used across different platforms and operating systems. Given the fact that RECT operates on different small Controllers, portability is very important.
    \item \textbf{Configuration:} There is no need for any complex setup or configuration when working with SQLite. We only need a few tables to work with, so having to configure a database on each controller wouldn't be worth the effort.
    \item \textbf{Local:} SQLite doesn't need any separate server or installation. It contains all the features we need in a small an independent package.
\end{enumerate}

In our case we use rusqlite in order to save the config.json file, containing date for the available connections. Accessing the Data from the database is simply much quicker 
and saver than reading from the file when we need it. 

\subsection{Serde}
\textbf{Author: Christoph Fellner}

Serde\footcite{serde} is used for \textbf{ser}ializing and \textbf{de}serializing data structures efficiently and generically in Rust. You can find a detailed serde overview 
\href{https://serde.rs/}{here}.
Serde provides functions to deserialize JSON-files in a simple and quick way, this allows us to use the data from the config.json file in our program with just a few lines 
of code. With serde we deserialize the data from the JSON-file into a self-made rust structure, which allows us to use the data properly.  

\subsection{Tokio}
\textbf{Author: Christoph Fellner}

Tokio\footcite{tokio} is asynchronous runtime for rust. In rust asynchronous code doesn't run on it's own in order to make it work the programmer has to use a runtime like 
Tokio. You can find more in depth descripton of Tokio \href{https://tokio.rs/tokio/tutorial}{here}. 
We picked Tokio because it is the most widely used runtime for async rust code. There are also a lot of Tutorials for Tokio and it is fairly simple to use.
Tokio as our asynchronous runtime allows us to execute multi-threaded async code safely.  

\begin{verbatim}
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn client_test(){ 
    let ser = test_server::run_server();
    println!("Server started");
    let cl = test_client::client_test();
    println!("Client started");

    tokio::select! {
        biased; 
        _ = ser => panic!("server returned first"),
        _ = cl => (),
    }           
}
\end{verbatim}

Using Tokio makes it possible to run multiple async functions at the same time. In the example above we start a server and a client and then wait for the first one to finish. 
This is done using the tokio::select! macro. The macro takes a list of futures and waits for the first one to finish. In our case we want to wait for the client to finish 
first, so we panic if the server finishes first. If the client finishes first we just return. Any occoring Errors are cathed and returned as Result.
The two functions \verb+run_server+ and \verb+client_test+ are both async functions. The server function is a simple echo server, that waits for a message from the client and 
then sends it back. The client function sends a message containing an url and a vote to the server and then waits for the response. Server and Client are connected via a gRPC 
connection. 

\subsection{Tokio-Rusqlite}
\textbf{Author: Christoph Fellner}

Tokio-Rusqlite\footcite{tokiolite} is a library that combines the functionality of Tokio and Rusqlite. It allows us to use Rusqlite in an asynchronous way. 

\subsection{Tonic}
\textbf{Author: Christoph Fellner}

Tonic\footcite{tonic} is a rust library that implements gRPC with a focus on high performance, interoperability, and flexibility. Tonic supports async/await which makes it very kompatible 
with Tokio. With gRPC Protocol Buffers are used to descripe interfaces. Tonic allows us to simply use Protocol Buffers to define our interfaces and then generate the necessary
Rust code for us.
The example for Tokio above uses the Tonic library to convert the following Protocol Buffer into Rust code, in order to use it in the client and server functions as Service.

\begin{verbatim}
syntax = "proto3";
package voting;
        
service Voting {
    rpc Vote (VotingRequest) returns (VotingResponse);
}
        
message VotingRequest {
    string url = 1;
        
    enum Vote {
        UP = 0;
        DOWN = 1;
    }
    Vote vote = 2;    
}
        
message VotingResponse {
    string confirmation = 1;
}
\end{verbatim}

In order to translate the Protocol Buffer into Rust code we use the \verb+include_proto!+ function from the Tonic library. This function takes the path to the Protocol Buffer 
file and generates the Rust code for the Service.

\filbreak