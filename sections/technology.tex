\chapter{Technology}


\section{Wombat}

\section{Python}

\section{C++}
\textbf{Author: Maximilian Dragosits}

C++ is a high-level precompiled programming language with support for low level memory manegment, object oriented programming, generic and functional programming.
It was designed and created by Danish computer scientist Bjarne Stroustrup with efficiency, performance and flexibility as its core goals.\footcite{lecture_essence_cpp}
Being based on C, and due to its highly sophisticated design C++ is being used in all kinds of places nowadays. From desktop applications, servers, video games and 
even very performance critical use cases like digital equipment in space. The International Organization for Standardization (ISO) standardized this proagramming
language in 1998 as SO/IEC 14882:1998. Due to its populatrity many libraries and frameworks for C++ have been made including Catch2\footcite{catch2_git} and 
Doxygen\footcite{doxygen_main_site} both of which are being used in this project. We chose this coding language as one of the two frontend because of its speed and
efficiency as well as the sheer number of external frameworks and libraries already created for it, which are essential in the development of the RECT library. 

\section{Rust}
\textbf{Author: Jeremy Sztavinovszki}

Rust is a general purpose multi paradigm programming language used in many fields ranging from embedded programming to web development. Although it is a relatively young language, having released its version 1.0 on May 15th 2015, it has seen great adoption from developers and has a big community. The language tries to be as fast as possibly, while still remaining memory-safe, which it achieves using its borrow checker. Even though it is possible to write unsafe code in Rust, that is not checked by the borrow checker, it is custom to keep the unsafe parts as small as possible.
Rust has a great ecosystem driven by the Rust Foundation and the Rust community. There are many tools, such as cargo, or rust-gdb, that provide great developer experience.
Right now there is now standardized async-runtime, so you normally use runtimes like tokio, async-std, or smol for programming asynchronously.

\section{gRPC}
\textbf{Author: Maximilian Dragosits}

gRPC\footcite{grpc_main_site} is an open source framework, that facilitates Remote Procedure Calls (RPC) across a multitude of enviornments. It has a wide varity of use cases in terms of
service to service connections and useage in the development of microservices and libraries. The framework is available in 11 different programming languages and 
has a simple service definition and generation structure in order to streamline the process of integration. It also has pluggable authentication, load balancing, tracing
and health checking in order to control service communication. gRPCs ability to connect a client to backend services is particularly importent for this project 
and is therefore used to handle the communication from the individual Python and C++ frontends to the Rust backend and vice versa.

\subsection{Protocol Buffers}

Protocol Buffers are a platform neutral way to serialize structured data similiar to XML, JSON or YAML. These data constructs can easily be used by automatically
generated source code in a multitude of different programming languages of the developers choosing. Including, but not limited to, Java, Kotlin, Python and various
C-based languages. 

%Explain how a .proto file is defined

\section{Bluetooth Low Energy}
\textbf{Author: Jeremy Sztavinovszki}

Bluetooth Low Energy (BLE) is a low powered, low cost, low bandwidth radio communication technology, that was originally developed at Nokia in a project named Wibree. It was later noticed by the Bluetooth Special interest group and became part of the Bluetooth 4.0 Core Specification. Nowadays it is often used in all things ranging from wireless headphones to IOT devices and has seen great adoption in many different areas. The BLE protocol Stack, like others (e.g. TCP/IP) is separated into different layers. The layers are split into 3 overarching layers. There is the Application, Host and Controller layers.

\subsection{Application-Layer}
The Application-Layer is the highest layer in the stack and is responsible for containing logic, user interface and handling the data of the actual application using BLE.

\subsection{Host-Layer}
The Host-Layer itself splits off into several layers.

\subsubsection{Generic Access Profile GAP}
GAP

\subsubsection{Generic Attribute Profile GATT}
test

\subsubsection{Logical Link Protocol and Adaptation Protocol L2CAP}
test

\subsubsection{Attribute Protocol ATT}
test

\subsubsection{Security Manager Protocol SMP}
test

\subsubsection{Host Controller Interface HCI (Host side)}
test

\subsection{Controller}
The controller is the layer works closely with the hardware. It contains the following layers

\subsubsection{Host Controller Interface (Controller side)}
test
\subsubsection{Link Layer LL}
test
\subsubsection{Physical Layer PHY}
test

\section{Libraries}

\subsection{Catch2}
\textbf{Author: Maximilian Dragosits}

Catch2\footcite{catch2_main_site} is a C++-based unit testing framework. It is design to be easily integrated into C++ code and match the overall look and feel
of normal functions and booelean expressions. This framework also provides micro-benchmarking capabilities. It is a good fit for this project, because it serves
to develope the C++ frontend with unit tests in mind and optimisations spurred on by benchmarks mesuring the speed and efficiency of the implemented methods.

\subsubsection{Unit Tests}

Unit Tests in Catch2 are defined very similarly as normal functions in C++. This example, pulled from the Github repositiory of Catch2, shows the simplicity of
this framework and its integration into projects.

\begin{verbatim}
    #include <catch2/catch_test_macros.hpp>

    #include <cstdint>
    
    uint32_t factorial( uint32_t number ) {
        return number <= 1 ? number : factorial(number-1) * number;
    }
    
    TEST_CASE( "Factorials are computed", "[factorial]" ) {
        REQUIRE( factorial( 1) == 1 );
        REQUIRE( factorial( 2) == 2 );
        REQUIRE( factorial( 3) == 6 );
        REQUIRE( factorial(10) == 3'628'800 );
    }
\end{verbatim}

First the relevant Catch2 headers are included and then a function with a return value is defined. In this case it is the function factorial. 
This function will be executed by Catch2 during the testing process. Then a test case is a macro defined as:

\begin{verbatim}
TEST_CASE(string testname, string tags) {...test...}
\end{verbatim}

The Argument \textit{testname} is a arbitrary name given to the unit test, which is then later during the running of the test printed alongside the results of the macro.
Tags can be given to the test by inputting one or multiple tags into the \textit{tags} field and change the behavoir of the macro accordingly. In the case of the example above
the only given tag is the name of the function to be tested. After this the \textit{TEST\_CASE} macro has a curly brackes-enclosed body in which the logic of the test can 
be defined.
This requieres the use of other specific macros included in the Catch2 framework. For example:

\begin{verbatim}
REQUIRE( function(value) == expexted_value );
CHECK( function(value) == expexted_value );
\end{verbatim}

The two macros described above, REQUIRE and CHECK, operate in a similar way. They both execute the given \textit{function} with the provided \textit{value} or \textit{values}
and then assert if the returned data matches the \textit{expected\_value}. If it does then it was successful and the rest of the \textit{TEST\_CASE} is executed. The difference 
between REQUIRE and CHECK is however that if a REQUIRE macro fails it throws an execption and the unit test is stopped from executing the remainder of code inside it.

\subsubsection{Micro-benchmarks}
%Explain how to make a micro benchmark in Catch2

\subsection{Doxygen}
\textbf{Author: Maximilian Dragosits}
tbd
%Explain what Doxygen is

\subsubsection{Documentation}
%Explain how to document with Doxygen

\subsection{Rusqlite}
\textbf{Author: Christoph Fellner}

Rusqlite is an ergonomic wrapper for using SQLite from Rust similar to rust-postgres. It provides an easy-to-use interface to work with SQLite databases. Using the functions provided by rusqlite you can perform all the common database operations, such as creating tables, inserting Data, querying data, and more simply within your code. 

We choose this library for SQLite mainly because of three reasons:
\begin{enumerate}
    \item \textbf{Portability:} SQLite databases can be used across different platforms and operating systems. Given the fact that RECT operates on different small Controllers, portability is very important.
    \item \textbf{Configuration:} There is no need for any complex setup or configuration when working with SQLite. We only need a few tables to work with, so having to configure a database on each controller wouldn't be worth the effort.
    \item \textbf{Local:} SQLite doesn't need any separate server or installation. It contains all the features we need in a small an independent package.
\end{enumerate}

In our case we use rusqlite in order to save the config.json file, containing date for the available connections. Accessing the Data from the database is simply much quicker and saver than reading from the file when we need it. 

\subsection{Serde}
\textbf{Author: Christoph Fellner}

Serde is a framework for rust, used for \textbf{ser}ializing and \textbf{de}serializing data structures efficiently and generically. You can find a detailed serde overview \href{https://serde.rs/}{here}.

Serde provides functions to deserialize JSON-files in a simple and quick way, this allows us to use the data from the config.json file in our program with just a few lines of code.

With serde we deserialize the data from the JSON-file into a self-made rust structure, which allows us to use the data properly.  

\subsection{Tokio}
\textbf{Author: Christoph Fellner}

Tokio is asynchronous runtime for rust. In rust asynchronous code doesn't run on it's own in order to make it work the programmer has to use a runtime like Tokio. You can find more in depth descripton of Tokio \href{https://tokio.rs/tokio/tutorial}{here}. 

We picked Tokio because it is the most widely used runtime for async rust code. There are also a lot of Tutorials for Tokio and it is fairly simple to use.

Tokio as our asynchronous runtime allows us to execute multi-threaded async code safely.  

\subsection{Tonic}
\textbf{Author: Christoph Fellner}

Tonic is a rust framework that implements gRPC.

\filbreak
